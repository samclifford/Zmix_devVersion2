library(devtools)
library(roxygen2)
library(roxygen)
library(roxygen2)
install_github('Zmix_devVersion2','zoevanhavre', args=c('--library="H:/Documents/R/win-library/3.1"'))#
	library(ZmixUnderConstruction)
?install_github
abs((5-6)/5)
abs((5-9)/5)+abs((8-6)/8)
abs((5-6)/5)+abs((8-9)/8)
abs((5-6))/5+abs((8-9))/8
abs((5-9))/5+abs((8-6))/8
#' gibbsHMM_PT#
#'#
#' density of dirichlet#
#' @param x, alpha, log=False#
#' @keywords dirichlet#
#' @export#
#' @examples dDirichlet(c(.1, .9), c(0.1,0.1))#
gibbsHMM_PT<-function(YZ, M=2000, K=5, mu0=0, var0=100, alphaMin=0.5, J=10){#
    #____SET UP_________________________________________#
    ifelse(class(YZ)=='data.frame',    Y<-YZ$O, Y<-YZ)#
    n=length(Y) # sample size#
    varknown<-1 # known variace #
     # INITIALIZE#
    startVal<-makeStart(Y, K);  states0<-startVal$states0   #FUNK#
        TrackParallelTemp<-matrix(nrow=M, ncol=J)#
         TrackParallelTemp[1,]<-c(1:J)#
      # TO BE INCORPORATED INTO J LISTS#
    MU<-replicate(J,  matrix(nrow=M, ncol=K),  simplify=F)#
    Q  <-replicate(J, matrix(nrow=M, ncol=K*K) , simplify=F)#
    q0 <-replicate(J, matrix(nrow=M, ncol=K), simplify=F)#
    Z  <-replicate(J, matrix(nrow=M, ncol=n+1)  ,  simplify=F)  #include 0 for initial state to be estimated too?#
   SteadyScore<-data.frame("Iteration"=c(1:M), "K0"=K) ##### THIS IS NEW###
#
    K0Final<-matrix(nrow=M, ncol=J)#
    MAP<-c(1:M)  # KEEP TARGET ONLY#
    # ALPHA#
          alphaMAX<-(K-1)*(1+K-2+alphaMin)*(1+1/( (1/2) - alphaMin*(K-1))) -(K-1)*alphaMin+0.1#
          AllAlphas<-matrix(nrow=J, ncol=K)#
          AllAlphas[,1]<-alphaMAX#
         # AllAlphas[,2:K]<-seq(alphaMAX, alphaMin, length=J)#
          AllAlphas[,2:K]<-      c( alphaMin+(alphaMAX-alphaMin)/c(1:(J-1))^3, alphaMin)#
#
    # functions#
    for (m in 1:M){ #
          if(m %% 100==0){Sys.sleep(0.01)#
          par(mfrow=c(1,3))#
          plot(SteadyScore$K0~SteadyScore$Iteration, main='#non-empty groups', type='l')#
          ts.plot(q0[[J]], main='q0 from target posterior', col=rainbow(K))#
          ts.plot(TrackParallelTemp[,c(J:1)], main='Track Parallel Tempering', col=rainbow(J))#
          #ts.plot(Bigmu[[nCh]], main='emptying Mu', col=rainbow(k))#
          #image(ZSaved[[nCh]][order(Y),], col=rainbow(K), main="Allocations")#
          Sys.sleep(0)}#
      for (j in 1:J){ # FOR EACH CHAIN           #
# FOR EACH CHAIN...#
#
                      # 1 Parameters given states Z(m-1)#
                      # 1.1  Transition matrix Q from conditional posterior#
                        if (m==1) {nt<-CountTrans(states0, K)#
                        } else { nt<-CountTrans(Z[[j]][m-1,],K)}   # HERE ACCESS STATES#
                        # draw transition probs for state 1:K#
                        # for (i in 1:K) qnew[i,]<-rdirichlet(par=  nt[i,]+AllAlphas[j, ])#
                     #    for (i in 1:K) print(rdirichlet(par=  nt[i,]+AllAlphas[j, ]))#
#
                    qnew<- t(apply( nt,1, function(x) rdirichlet( par=x+AllAlphas[j, ])))#
                    q0new<-getq0NEW(qnew)  #
#
                        #METROPOLIS Hastings STEP     #
                  #      if (m==1){ A<-q0new[states0[1]]/startVal$q0[states0[1]]#
                   #           ifelse(A>runif(1,c(0,0.99)), qok<-qnew , qok<-qnew)        #
                   #     } else  { A<-q0new[Z[[j]][m-1,1]]/q0[[j]][m-1,Z[[j]][m-1,1]]#
                    #                 U<-runif(1,c(0,0.99))#
                         #         if (A>U){ qok<-qnew}#
                if (m>1){   #
                  A<-q0new[Z[[j]][m-1,1]]/q0[[j]][m-1,Z[[j]][m-1,1]]   ;  U<-runif(1,c(0,0.99))#
                  if(A>runif(1,c(0,0.99))){ #
                     #    Accept new values#
                        Q[[j]][m,]<-as.vector(t(qnew))#
                        q0[[j]][m,]<-q0new#
                                } else {#
                       Q[[j]][m,]<-as.vector(t(Q[[j]][m-1,]))#
                       q0[[j]][m,]<-q0[[j]][m-1,]  #
                                }}else{ Q[[j]][m,]<-as.vector(t(qnew))#
                        q0[[j]][m,]<-q0new  }#
#
                        # 1.2 Update mu's    #
                        # compute needed values:  N(k) = number of times state k is visited in chain, and sum(y_k) = sum of y's in state k #
                        if (m==1) {sumNcount<-formu(states0[-(n+1)],Y,K)#
                        } else {sumNcount<-formu(Z[[j]][m-1,-(n+1)], Y,K)}   #
                           sumtot<-cbind(sumNcount$sumy, sumNcount$ny)                                                                                                    #       sums<-sumNcount$sumy ;    tots<-sumNcount$ny#
                      # new means          #
                      mudraw<-apply(sumtot, 1,  function (x)     rnorm(1, mean= ((mu0/var0)+(x[1]/varknown)) / ((1/var0)+(x[2]/varknown)), sd= sqrt( 1/( (1/var0) + (x[2]/varknown)))  ))#
#
                  #SAVE sampled parameters#
                  #Q[[j]][m,]<-as.vector(t(qok))#
                 # q0[[j]][m,]<-getq0NEW(qok)  #
                  MU[[j]][m,]<-mudraw  #
                    # 2 Update States given parameters#
                  newZ<- UpdateStates( Y, Q[[j]][m,], MU[[j]], initS= q0[[j]][m,], m)#
                  Z[[j]][m,]<-newZ$Z#
                  if(j==J) MAP[m]<-newZ$MAP#
             } #end of PT chain loop#
## PT move#
#
          if(m>1) {TrackParallelTemp[m,]<-TrackParallelTemp[m-1,]}     #
          if(m>20){#
          if( sample(c(1,0),1, 0.9)==1){   # FREQ OF TEMPERING! #
          Chain1<-sample( 1:(J-1), 1)   #
          Chain2<-Chain1+1#
          MHratio<- parallelAccept(q0[[Chain1]][m,], q0[[Chain2]][m,], AllAlphas[ Chain1,] , AllAlphas[Chain2,] )#
          if (MHratio==1){                                 # switch #
                   #new#
                   .tpt1<-  TrackParallelTemp[m,Chain1 ]#
                   .tpt2<-  TrackParallelTemp[m,Chain2 ]             #
                  TrackParallelTemp[m,Chain1 ]<-.tpt2#
                  TrackParallelTemp[m,Chain2 ]<-.tpt1 #
          .p1<- q0[[Chain1]][m,]#
          .p2<- q0[[Chain2]][m,]#
          q0[[Chain1]][m,]<-.p2#
          q0[[Chain2]][m,]<-.p1#
          .m1<- MU[[Chain1]][m,]#
          .m2<- MU[[Chain2]][m,]#
          MU[[Chain1]][m,]<-.m2#
          MU[[Chain2]][m,]<-.m1#
          .s1<- Q[[Chain1]][m,]#
          .s2<- Q[[Chain2]][m,]#
          Q[[Chain1]][m,]<-.s2#
          Q[[Chain2]][m,]<-.s1#
                                                                                                                # Zs#
          .z1<- Z[[Chain1]][m,]#
          .z2<- Z[[Chain2]][m,]#
          Z[[Chain1]][m,]<-.z2#
          Z[[Chain2]][m,]<-.z1#
          }   }   }#
   SteadyScore$K0[m]<-sum(table(Z[[J]][m,])>0)#
#
# for all chains #
       K0Final[ m, ]<-sapply(   Z  ,  function(x)  sum(table(x[m,])>0))#
#
            }  # end of iteration loop#
      return(list("Means"=MU[[J]], "Trans"=Q[[J]], "States"=Z[[J]], "q0"=q0[[J]], "YZ"=YZ, "MAP"=MAP, "K0"=K0Final))#
      }
#' PostProcessing function univ#
#'#
#' This function draws samples from a Wishart dist#
#' @param v and s#
#' @keywords Wishart#
#' @export#
#' @examples#
#' #nope#
#
Zswitch_hmm<-function(GrunK0, PropMin=0.1 ){#
			K<-dim(GrunK0$q0)[2]#
			 # Pick Reference = Max log Likelihood#
			wml<-which.max(GrunK0$MAP)#
			Zref<-factor(GrunK0$Z[wml,], levels=1:K,ordered=FALSE) #
			FinalOrderChoice<-order(GrunK0$q0[wml,], decreasing=TRUE)		#
			non0ref<-FinalOrderChoice[1:sum(table(Zref)>0)]#
			refComp<-c(GrunK0$q0[wml,non0ref], GrunK0$Mu[wml,non0ref])  # use only q0 and mu#
			Zref<- factor(Zref)#
#
			# RENAME TO neat numbers#
			levels(Zref)<- c(1:K)[order(FinalOrderChoice[1:sum(table(Zref)>0)])]#
			# storage dataframes:#
			numK0now<-sum(table(Zref )>0) #
			numPar<-length(unlist(lapply(1:dim(GrunK0$Z)[1], rep, numK0now)))#
			AllPars<-data.frame(matrix(0, ncol=4+numK0now, nrow=numPar) )#
			AllPars[,1]<-unlist(lapply(1:dim(GrunK0$Z)[1], rep, numK0now))#
			Zfixed<-GrunK0$Z#
			#for each iteration#
			for(.iter in 1:dim(GrunK0$q0)[1]){#
				#Store current states#
				Znow<-factor(GrunK0$Z[.iter,])    #
				#identify potential candidate switches:#
				CandiCells<-table(Znow , Zref)/apply(table(Znow , Zref), 1, sum)>PropMin#
				getCandi<-function(x) { as.numeric(as.character(row.names(as.matrix(x))[x])) }#
				ListCandi<- apply(CandiCells, 1, getCandi)#
				# R stuff to make sure it deals with inputs correctly#
				if(class(ListCandi)=='matrix'){#
				ListCandi<-split(ListCandi, rep(1:ncol(ListCandi), each = nrow(ListCandi)))#
				Candies<-expand.grid(ListCandi)  # each row is a labelling#
				names(Candies)<-row.names(CandiCells)   # RAAAAH#
				} else if (class(ListCandi)=='numeric'){#
				Candies<-ListCandi#
				} else {#
				Candies<-expand.grid(ListCandi)  # each row is a labelling#
				names(Candies)<-row.names(CandiCells)   # RAAAAH#
				}#
#
				namesCandies<-names(Candies)#
				# Catch if no appropriate seperation available at all, check all permutations of potential groups. Only occurs in really bad models with bad convergence.				#
				done<-0#
				if(class(Candies)=='data.frame'){#
				if  ( max(sapply(apply(Candies, 1, unique), length))<length(row.names(CandiCells))){#
					#Candies<- permutations(K)#
					Candies<- matrix( as.numeric( row.names(CandiCells))[permutations(numK0now,numK0now )], ncol=numK0now)	#
					 colnames(Candies)<-as.numeric(names(as.data.frame(CandiCells)))#
### ISSUE HERE#
						#MinusRefPars<-function(x) 	{	flp<- as.numeric(  row.names(CandiCells))[unlist(Candies[x,])]#
					#		flp<-na.omit(flp)#
				#		if(length(unique(flp))<length(flp)) { Inf#
				#		} else {sum(abs( (refComp	-  c(GrunK0$q0[.iter,flp], GrunK0$Mu[.iter,flp]))/refComp))	}}#
						MinusRefPars_catch<-function(x) 	{ flp<- Candies[x,]#
						if(length(unique(flp))<length(flp)) { Inf#
						} else {sum(abs( (refComp	-  c(GrunK0$q0[.iter,flp], GrunK0$Mu[.iter,flp]))/refComp))	}}#
#
						BestOne<-which.min( sapply(1:dim(Candies)[1] , MinusRefPars_catch))  # find the best perm out of options#
						BestOne<-Candies[BestOne,]#
						#if(is.null(names(BestOne))) {names(BestOne)<-namesCandies}#
						flp<-as.numeric(BestOne)[as.numeric(names(BestOne))]#
						# Allocations#
						Znew<-Znow;				levels(Znew)<-as.numeric(names(BestOne))#
						Zfixed[.iter,]<-as.numeric(as.character(Znew))#
						# Parameters#
						#flp<- as.numeric( row.names(CandiCells)[unlist(BestOne)])#
						swQ<-nowQ<-matrix(GrunK0$Q[.iter,], nrow=K, byrow=T)[flp, flp]					#
						combinePars<- cbind(.iter, 1:numK0now,  GrunK0$q0[.iter,flp],GrunK0$Mu[.iter,flp],swQ)#[order(as.numeric(BestOne)), decreasing=FALSE),]#
						AllPars[AllPars[1]==.iter,]<- combinePars#
						done<-1#
#
					}}#
					#else{#
					#	if  (length(unique(Candies))<length(row.names(CandiCells))){#
					#Candies<- permutations(K)}#
					#} #
			if (done==0){#
			MinusRefPars<-function(x) 	{	flp<- as.numeric(  row.names(CandiCells)[unlist(Candies[x,])])#
								flp<-na.omit(flp)#
							if(length(unique(flp))<length(flp)) { Inf#
							} else {sum(abs( (refComp	-  c(GrunK0$q0[.iter,flp], GrunK0$Mu[.iter,flp]))/refComp))	}}#
				if( sum( apply(CandiCells, 1, sum)) >  dim(CandiCells)[1] ){#
					BestOne<-which.min( sapply(1:dim(Candies)[1] , MinusRefPars))  # find the best perm out of options#
					BestOne<-Candies[BestOne,]#
					} else {BestOne<- Candies }   # chose this one if no comparing needed#
				if(is.null(names(BestOne))) {names(BestOne)<-namesCandies}#
				# Allocations#
				Znew<-Znow; levels(Znew)<-as.numeric(BestOne)#
				Zfixed[.iter,]<-as.numeric(as.character(Znew))#
				# OK WORKS#
					# Parameters#
				## FIX BELOW  "  la longueur des donn'ees [21] n'est pas un diviseur ni un multiple du nombre de colonnes [5]"#
flp<- as.numeric( row.names(CandiCells)[unlist(BestOne)])#
swQ<-nowQ<-matrix(GrunK0$Q[.iter,], nrow=K, byrow=T)[flp, flp]					#
combinePars<- cbind(.iter, as.numeric(BestOne),  GrunK0$q0[.iter,flp],GrunK0$Mu[.iter,flp],swQ)#[order(as.numeric(BestOne)), decreasing=FALSE),]#
AllPars[AllPars[1]==.iter,]<- combinePars#
			}#
		}#
			# sumarise Z (find max)#
			maxZ<-function (x)  as.numeric(names(which.max(table( x ))))#
			Zhat<- factor( apply(Zfixed, 2,maxZ))#
			#levels(Zhat)<- levels(Zhat)<-as.character(BestOne)#
			return(list('Pars'=AllPars, 'Z'=Zfixed))#
			}
load('~/Google Drive/P3 HMMs/R Code/Results Oct 23/Sim1_a01n100.RDATA')
ls()
load('~/Google Drive/P3 HMMs/R Code/Results Oct 23/Sim1_a01n500.RDATA')
Grun<-Sim1_a01n100#
mydata<-Sim1_a01n100$YZ
prep=10#
Propmin=0.05#
isSim=TRUE#
simlabel="Sim1_a01n100"
ifelse(isSim==TRUE, Y<-mydata$O,  Y<-mydata)#
#
		n<-length(Y)  #
		K<-dim(Grun$q0)[2]	#
		## 1. split by K0#
		targetK0<-Grun$K0[,dim(Grun$K0)[2] ] #
		K0<-as.numeric(names(table(targetK0 )))#
		# SAVE table of tests, parameter estimates and clustering (Z's)#
		p_vals<-data.frame("K0"=K0, "PropIters"=as.numeric(table(Grun$K0[,dim(Grun$K0)[2]]))/dim(Grun$q0)[1],#
			"RAND"=NA, "MAE"=NA, "MSE"=NA,"Pmin"=NA, "Pmax"=NA, "Concordance"=NA, "MAPE"=NA, "MSPE"=NA)
K0estimates<-vector("list", length(K0))
.K0
.K0<-1
GrunK0<-Grun#
		# split data by K0#
		.iterK0<- c(1:dim(Grun$q0) [1])[ targetK0  ==K0[.K0]]#
		GrunK0$Mu<-	Grun$Mu[.iterK0,]#
		GrunK0$Q<-	Grun$Q[.iterK0,]#
		GrunK0$q0<-	Grun$q0[.iterK0,]#
		GrunK0$MAP<-	Grun$MAP[.iterK0]#
		GrunK0$Z<-	Grun$Z[.iterK0,]#
		GrunK0$K0<-	Grun$K0[.iterK0]#
#
		## 2. unswitch#
		GrunK0us<-Zswitch_hmm(GrunK0,Propmin )
Grun$K0
nmes(Grun)
names(Grun)
head(Grun$K0)
Sim1_mu<-3;  Sim1_q0<-1; Sim1_Q<-1#
#
  Sim2_mu<-c(0,3,10);    #
  Sim2_Q<-matrix( c(  0.2,0.3,0.5,    0.5,0.25,0.25,    0.25, 0.65, 0.1), nrow=3, byrow=T)#
  Sim2_q0<-getq0NEW(Sim2_Q)#
  Sim3_mu<-c(0,2,6);    #
  Sim3_Q<-matrix( c(  0.2,0.3,0.5,    0.5,0.25,0.25,    0.25, 0.65, 0.1), nrow=3, byrow=T)#
  Sim3_q0<-getq0NEW(Sim3_Q)#
#
  Sim4_mu<-c(1,4,-10);    #
  Sim4_q0<-c(.7, .25, 0.05)#
FunkSim1<-function(n){ data.frame( "States"=1, "Observed"=rnorm(n, mean=3, sd=1)) }#
FunkSim2<-function(n){   SimHMM( Q=Sim2_Q,  Mu= Sim2_mu, n)  }#
FunkSim3<-function(n){   SimHMM( Q=Sim3_Q,  Mu= Sim3_mu, n)  }#
# must be multiples of 100...#
FunkSim4<-function(n){#
        nrep<-n/100#
        X_100<-c( rep(1, 20), rep(2, 15), rep(1, 5), rep(3, 3), rep( 1, 25), rep(2, 10), rep(1, 20), rep(3, 2))#
         X<-rep(X_100, nrep)#
         Y<-sapply( X, function(x)   rnorm(1, Sim4_mu[x], 1) ) #
       return(data.frame("States"=X, "Observed"=Y))#
		}#
# LYRA
Sim1_a01n100<-gibbsHMM_PT( YZ=FunkSim1(100),  M=100, alphaMin=0.01, J=30  ,K=10)
setwd("/Users/zoevanhavre/Google Drive/GitHub")
setwd("./Zhmm.0")
library(devtools)#
library(roxygen2)
document()
setwd("..")
getwd()
setwd("./Zmix_devVersion2")
document()
document()
